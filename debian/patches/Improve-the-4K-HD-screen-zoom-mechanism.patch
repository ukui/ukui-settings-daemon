Index: ukui-settings-daemon/data/org.ukui.SettingsDaemon.plugins.xsettings.gschema.xml.in
===================================================================
--- ukui-settings-daemon.orig/data/org.ukui.SettingsDaemon.plugins.xsettings.gschema.xml.in	2020-07-22 11:17:15.639393569 +0800
+++ ukui-settings-daemon/data/org.ukui.SettingsDaemon.plugins.xsettings.gschema.xml.in	2020-07-22 11:23:30.363851915 +0800
@@ -10,5 +10,16 @@
       <summary>Priority to use for this plugin</summary>
       <description>Priority to use for this plugin in ukui-settings-daemon startup queue</description>
     </key>
+    <key type="a{sv}" name="overrides">
+      <default>{}</default>
+      <summary>A dictionary of XSETTINGS to override</summary>
+      <description>This dictionary maps XSETTINGS names to overrides values. The values must be either strings, signed int32s or (in the case of colors), 4-tuples of uint16 (red, green, blue, alpha; 65535 is fully opaque).</description>
+    </key>
+    <key name="scaling-factor" type="i">
+      <default>0</default>
+      <range min="0" max="3"/>
+      <summary>Window Scaling Factor</summary>
+      <description>This controls the GTK scale factor that maps from window coordinates to the actual device pixels. On traditional systems this is 1, but on very high density displays (e.g. HiDPI, Retina) this can be a higher value (often 2). Set to 0 to auto-detect.</description>
+    </key>
   </schema>
 </schemalist>
Index: ukui-settings-daemon/plugins/xsettings/usd-xsettings-manager.c
===================================================================
--- ukui-settings-daemon.orig/plugins/xsettings/usd-xsettings-manager.c	2020-07-22 11:17:15.711393656 +0800
+++ ukui-settings-daemon/plugins/xsettings/usd-xsettings-manager.c	2020-07-22 20:27:07.839354164 +0800
@@ -61,6 +61,10 @@
 #define FONT_RGBA_ORDER_KEY   "rgba-order"
 #define FONT_DPI_KEY          "dpi"
 
+#define XSETTINGS_PLUGIN_SCHEMA "org.ukui.SettingsDaemon.plugins.xsettings"
+#define XSETTINGS_SCALING_KEY   "scaling-factor"
+#define XSETTINGS_OVERRIDE_KEY  "overrides"
+
 /* X servers sometimes lie about the screen's physical dimensions, so we cannot
  * compute an accurate DPI value.  When this happens, the user gets fonts that
  * are too huge or too tiny.  So, we see what the server returns:  if it reports
@@ -75,6 +79,14 @@
 #define DPI_LOW_REASONABLE_VALUE 50
 #define DPI_HIGH_REASONABLE_VALUE 500
 
+/* The minimum resolution at which we turn on a window-scale of 2 */
+#define HIDPI_LIMIT (DPI_FALLBACK * 2)
+
+/* The minimum screen height at which we turn on a window-scale of 2;
+ * below this there just isn't enough vertical real estate for GNOME
+ * apps to work, and it's better to just be tiny */
+#define HIDPI_MIN_HEIGHT 1500
+
 typedef struct _TranslationEntry TranslationEntry;
 typedef void (* TranslationFunc) (UkuiXSettingsManager  *manager,
                                   TranslationEntry      *trans,
@@ -91,8 +103,9 @@
 struct UkuiXSettingsManagerPrivate
 {
         XSettingsManager **managers;
-        GHashTable *gsettings;
-        GSettings *gsettings_font;
+        GHashTable        *gsettings;
+        GSettings         *gsettings_font;
+        GSettings         *plugin_settings;
         fontconfig_monitor_handle_t *fontconfig_handle;
 };
 
@@ -179,6 +192,62 @@
         }
 }
 
+/* Func: translate_string_string_window_buttons
+ * Set window button layout 
+ * 设置窗口按钮布局   
+ */
+static void
+translate_string_string_window_buttons (UkuiXSettingsManager *manager,
+                                        TranslationEntry      *trans,
+                                        GVariant              *value)
+{
+    int         i;
+    const char *tmp;
+    gchar *ptr, *final_str;
+
+    /* This is kind of a workaround. "menu" is useless in metacity titlebars
+     * it duplicates the same features as the right-click menu.
+     * In CSD windows on the hand it is required to show unique featues.
+     */
+    tmp = g_variant_get_string (value, NULL);
+
+    /* Check if menu is in the setting string already */
+    ptr = g_strstr_len (tmp, -1, "menu");
+
+    if (!ptr) {
+        /* If it wasn't there already, we add it... */
+
+        /* Simple cases, :* - all items on right, just prepend menu on left side*/
+        if (g_str_has_prefix (tmp, ":")) {
+            final_str = g_strdup_printf ("menu%s", tmp);
+       }
+       else
+        /* All items on left... * (no :), append menu - we want actual window
+           controls on the outside */
+        if (!g_strstr_len (tmp, -1, ":")) {
+            final_str = g_strdup_printf ("%s,menu", tmp);
+        }
+        else {
+            /* Items on both sides, split it, append menu to the lefthand, and re-
+             * construct the string with the : separator */
+            gchar **split = g_strsplit (tmp, ":", 2);
+            final_str = g_strdup_printf ("%s,menu:%s", split[0], split[1]);
+            
+            g_strfreev (split);
+        }
+   } else {
+       /* If menu was already included, just copy the original string */
+        final_str = g_strdup (tmp);
+    }
+
+    for (i = 0; manager->priv->managers [i]; i++) {
+            xsettings_manager_set_string (manager->priv->managers [i],
+                                          trans->xsetting_name,
+                                          final_str);
+    }
+    g_free (final_str);
+}
+
 static TranslationEntry translations [] = {
         { MOUSE_SCHEMA,     "double-click",           "Net/DoubleClickTime",           translate_int_int },
         { MOUSE_SCHEMA,     "drag-threshold",         "Net/DndDragThreshold",          translate_int_int },
@@ -198,7 +267,9 @@
         { INTERFACE_SCHEMA, "gtk-im-module",          "Gtk/IMModule",                  translate_string_string },
         { INTERFACE_SCHEMA, "icon-theme",             "Net/IconThemeName",             translate_string_string },
         { INTERFACE_SCHEMA, "file-chooser-backend",   "Gtk/FileChooserBackend",        translate_string_string },
-        { INTERFACE_SCHEMA, "gtk-decoration-layout",  "Gtk/DecorationLayout",          translate_string_string },
+        
+        { INTERFACE_SCHEMA, "gtk-decoration-layout",  "Gtk/DecorationLayout",          translate_string_string_window_buttons },
+
         { INTERFACE_SCHEMA, "gtk-shell-shows-app-menu","Gtk/ShellShowsAppMenu",        translate_bool_int },
         { INTERFACE_SCHEMA, "gtk-shell-shows-menubar","Gtk/ShellShowsMenubar",         translate_bool_int },
         { INTERFACE_SCHEMA, "menus-have-icons",       "Gtk/MenuImages",                translate_bool_int },
@@ -215,6 +286,74 @@
         { SOUND_SCHEMA, "input-feedback-sounds",      "Net/EnableInputFeedbackSounds", translate_bool_int }
 };
 
+/* Auto-detect the most appropriate scale factor for the primary monitor.
+ * A lot of this code is copied and adapted from Linux Mint/Cinnamon.
+ * 如果设置缩放为0，通过获取物理显示器的分辨率大小进行设置合适的DPI缩放
+ */
+static int
+get_window_scale_auto ()
+{
+        GdkDisplay   *display;
+        GdkMonitor   *monitor;
+        GdkRectangle  rect;
+        int width_mm, height_mm;
+        int monitor_scale, window_scale;
+
+        display = gdk_display_get_default ();
+        monitor = gdk_display_get_primary_monitor (display);
+
+        /* Use current value as the default */
+        window_scale = 1;
+
+        gdk_monitor_get_geometry (monitor, &rect);
+        width_mm = gdk_monitor_get_width_mm (monitor);
+        height_mm = gdk_monitor_get_height_mm (monitor);
+        monitor_scale = gdk_monitor_get_scale_factor (monitor);
+
+        if (rect.height * monitor_scale < HIDPI_MIN_HEIGHT)
+                return 1;
+
+        /* Some monitors/TV encode the aspect ratio (16/9 or 16/10) instead of the physical size */
+        if ((width_mm == 160 && height_mm == 90) ||
+            (width_mm == 160 && height_mm == 100) ||
+            (width_mm == 16 && height_mm == 9) ||
+            (width_mm == 16 && height_mm == 10))
+                return 1;
+
+        if (width_mm > 0 && height_mm > 0) {
+                double dpi_x, dpi_y;
+
+                dpi_x = (double)rect.width * monitor_scale / (width_mm / 25.4);
+                dpi_y = (double)rect.height * monitor_scale / (height_mm / 25.4);
+                /* We don't completely trust these values so both must be high, and never pick
+                 * higher ratio than 2 automatically */
+                if (dpi_x > HIDPI_LIMIT && dpi_y > HIDPI_LIMIT)
+                        window_scale = 2;
+        }
+
+        return window_scale;
+}
+
+/* Get the key value to set the zoom
+ * 获取要设置缩放的键值
+ */
+static int
+get_window_scale (UkuiXSettingsManager *manager)
+{
+        GSettings   *gsettings;
+        gint         scale;
+
+        /* Get scale factor from gsettings */
+        gsettings = g_hash_table_lookup (manager->priv->gsettings, XSETTINGS_PLUGIN_SCHEMA);
+        scale = g_settings_get_int (gsettings, XSETTINGS_SCALING_KEY);
+
+        /* Auto-detect */
+        if (scale == 0)
+                scale = get_window_scale_auto ();
+
+        return scale;
+}
+
 static double
 dpi_from_pixels_and_mm (int pixels,
                         int mm)
@@ -238,9 +377,10 @@
         screen = gdk_screen_get_default ();
         if (screen != NULL) {
                 double width_dpi, height_dpi;
+                Screen *xscreen = gdk_x11_screen_get_xscreen (screen);
 
-                width_dpi = dpi_from_pixels_and_mm (gdk_screen_get_width (screen), gdk_screen_get_width_mm (screen));
-                height_dpi = dpi_from_pixels_and_mm (gdk_screen_get_height (screen), gdk_screen_get_height_mm (screen));
+                width_dpi = dpi_from_pixels_and_mm (WidthOfScreen (xscreen), WidthMMOfScreen (xscreen)); //gdk_screen_get_width (screen), gdk_screen_get_width_mm (screen));
+                height_dpi = dpi_from_pixels_and_mm (HeightOfScreen (xscreen), HeightMMOfScreen (xscreen)); //gdk_screen_get_height (screen), gdk_screen_get_height_mm (screen));
 
                 if (width_dpi < DPI_LOW_REASONABLE_VALUE || width_dpi > DPI_HIGH_REASONABLE_VALUE
                     || height_dpi < DPI_LOW_REASONABLE_VALUE || height_dpi > DPI_HIGH_REASONABLE_VALUE) {
@@ -260,10 +400,9 @@
 static double
 get_dpi_from_gsettings_or_x_server (GSettings *gsettings)
 {
-        double value;
         double dpi;
 
-        value = g_settings_get_double (gsettings, FONT_DPI_KEY);
+        dpi = g_settings_get_double (gsettings, FONT_DPI_KEY);
 
         /* If the user has ever set the DPI preference in GSettings, we use that.
          * Otherwise, we see if the X server reports a reasonable DPI value:  some X
@@ -271,9 +410,7 @@
          * fonts which are unusable.
          */
 
-        if (value != 0) {
-                dpi = value;
-        } else {
+        if (dpi == 0) {
                 dpi = get_dpi_from_x_server ();
         }
 
@@ -284,6 +421,10 @@
 {
         gboolean    antialias;
         gboolean    hinting;
+
+        int         scaled_dpi;
+        int         window_scale;
+        
         int         dpi;
         char       *cursor_theme;
         int         cursor_size;
@@ -305,6 +446,7 @@
         char      *hinting;
         char      *rgba_order;
         double     dpi;
+        gint       scale;
 
         mouse_gsettings = g_hash_table_lookup (manager->priv->gsettings, MOUSE_SCHEMA);
 
@@ -312,13 +454,17 @@
         hinting = g_settings_get_string (manager->priv->gsettings_font, FONT_HINTING_KEY);
         rgba_order = g_settings_get_string (manager->priv->gsettings_font, FONT_RGBA_ORDER_KEY);
         dpi = get_dpi_from_gsettings_or_x_server (manager->priv->gsettings_font);
+        scale = get_window_scale (manager);
 
         settings->antialias = TRUE;
         settings->hinting = TRUE;
         settings->hintstyle = "hintslight";
+        settings->window_scale = scale;
         settings->dpi = dpi * 1024; /* Xft wants 1/1024ths of an inch */
+        settings->scaled_dpi = dpi * scale * 1024;
+
         settings->cursor_theme = g_settings_get_string (mouse_gsettings, CURSOR_THEME_KEY);
-        settings->cursor_size = g_settings_get_int (mouse_gsettings, CURSOR_SIZE_KEY);
+        settings->cursor_size = g_settings_get_int (mouse_gsettings, CURSOR_SIZE_KEY) * scale;
         settings->rgba = "rgb";
 
         if (rgba_order) {
@@ -393,7 +539,11 @@
                 xsettings_manager_set_int (manager->priv->managers [i], "Xft/Antialias", settings->antialias);
                 xsettings_manager_set_int (manager->priv->managers [i], "Xft/Hinting", settings->hinting);
                 xsettings_manager_set_string (manager->priv->managers [i], "Xft/HintStyle", settings->hintstyle);
-                xsettings_manager_set_int (manager->priv->managers [i], "Xft/DPI", settings->dpi);
+                
+                xsettings_manager_set_int (manager->priv->managers [i], "Gdk/WindowScalingFactor", settings->window_scale);
+                xsettings_manager_set_int (manager->priv->managers [i], "Gdk/UnscaledDPI", settings->dpi);
+                xsettings_manager_set_int (manager->priv->managers [i], "Xft/DPI", settings->scaled_dpi);
+                
                 xsettings_manager_set_string (manager->priv->managers [i], "Xft/RGBA", settings->rgba);
                 xsettings_manager_set_string (manager->priv->managers [i], "Xft/lcdfilter",
                                               g_str_equal (settings->rgba, "rgb") ? "lcddefault" : "none");
@@ -458,7 +608,7 @@
 	} else {
 		// unset, use default
 		strncpy(tmpCursorTheme, "DMZ-Black", 255);
-	        syslog(LOG_INFO, "use default theme name=%s=", tmpCursorTheme);
+	    //syslog(LOG_INFO, "use default theme name=%s=", tmpCursorTheme);
 	}
 	if (settings->cursor_size > 0) {
 		tmpCursorSize = settings->cursor_size;
@@ -475,14 +625,14 @@
     XreFilePath = g_build_filename (g_get_home_dir (), ".Xresources", NULL);
     date = g_malloc (40);
     g_sprintf(date,"Xft.dpi:%d\nXcursor.size:%d",
-                    settings->dpi/1024, settings->cursor_size);
+                    settings->scaled_dpi/1024, settings->cursor_size);
     res = g_file_set_contents(XreFilePath,date,strlen(date),NULL);
     if(!res)
         g_debug("Xresources File write failed ");
     /* end add by Shang Xiaoyang */
 
         update_property (add_string, "Xft.dpi",
-                                g_ascii_dtostr (dpibuf, sizeof (dpibuf), (double) settings->dpi / 1024.0));
+                                g_ascii_dtostr (dpibuf, sizeof (dpibuf), (double) settings->scaled_dpi / 1024.0));
         update_property (add_string, "Xft.antialias",
                                 settings->antialias ? "1" : "0");
         update_property (add_string, "Xft.hinting",
@@ -578,6 +728,52 @@
         }
 }
 
+/* 屏幕分辨率变化回调函数 */
+static void
+size_changed_callback (GdkScreen *screen, UkuiXSettingsManager *manager)
+{
+    int i;
+
+    update_xft_settings (manager);
+
+    for (i = 0; manager->priv->managers [i]; i++) {
+            xsettings_manager_notify (manager->priv->managers [i]);
+    }
+}
+
+/* 键值更改回调函数 */
+static void
+override_callback (GSettings             *settings,
+                   const gchar           *key,
+                   UkuiXSettingsManager *manager)
+{
+        GVariant *value;
+        int i;
+
+        value = g_settings_get_value (settings, XSETTINGS_OVERRIDE_KEY);
+
+        for (i = 0; manager->priv->managers[i]; i++) {
+                xsettings_manager_set_overrides (manager->priv->managers[i], value);
+        }
+
+        for (i = 0; manager->priv->managers [i]; i++) {
+                xsettings_manager_notify (manager->priv->managers [i]);
+        }
+        g_variant_unref (value);
+}
+
+/* 监听gsettings回调 */
+static void
+plugin_callback (GSettings             *settings,
+                 const char            *key,
+                 UkuiXSettingsManager  *manager)
+{
+
+    if (g_str_equal (key, XSETTINGS_OVERRIDE_KEY)) {
+        override_callback (settings, key, manager);
+    }
+}
+
 static void
 fontconfig_callback (fontconfig_monitor_handle_t *handle,
                      UkuiXSettingsManager       *manager)
@@ -665,11 +861,12 @@
         int               i;
         GVariant         *value;
 
-        if (g_str_equal (key, CURSOR_THEME_KEY) ||
-            g_str_equal (key, CURSOR_SIZE_KEY)) {
+        if (g_str_equal (key, XSETTINGS_SCALING_KEY )||
+            g_str_equal (key, CURSOR_THEME_KEY )||
+            g_str_equal (key, CURSOR_SIZE_KEY  )){
                 xft_callback (NULL, key, manager);
                 return;
-	}
+	    }
 
         trans = find_translation_entry (gsettings, key);
         if (trans == NULL) {
@@ -742,6 +939,7 @@
                         g_warning ("Could not create xsettings manager for screen %d!", i);
                         return FALSE;
                 }
+                g_signal_connect (screen, "size-changed", G_CALLBACK (size_changed_callback), manager);
         }
 
         return TRUE;
@@ -753,6 +951,7 @@
 {
         guint        i;
         GList       *list, *l;
+        GVariant    *overrides;
 
         g_debug ("Starting xsettings manager");
         ukui_settings_profile_start (NULL);
@@ -773,6 +972,8 @@
                              INTERFACE_SCHEMA, g_settings_new (INTERFACE_SCHEMA));
         g_hash_table_insert (manager->priv->gsettings,
                              SOUND_SCHEMA, g_settings_new (SOUND_SCHEMA));
+        g_hash_table_insert (manager->priv->gsettings,
+                             XSETTINGS_PLUGIN_SCHEMA, g_settings_new (XSETTINGS_PLUGIN_SCHEMA));
 
         list = g_hash_table_get_values (manager->priv->gsettings);
         for (l = list; l != NULL; l = l->next) {
@@ -788,10 +989,10 @@
                 gsettings = g_hash_table_lookup (manager->priv->gsettings,
                                                 translations[i].gsettings_schema);
 
-		if (gsettings == NULL) {
-			g_warning ("Schemas '%s' has not been setup", translations[i].gsettings_schema);
-			continue;
-		}
+		        if (gsettings == NULL) {
+			        g_warning ("Schemas '%s' has not been setup", translations[i].gsettings_schema);
+			        continue;
+		        }
 
                 val = g_settings_get_value (gsettings, translations[i].gsettings_key);
 
@@ -801,19 +1002,28 @@
 
         manager->priv->gsettings_font = g_settings_new (FONT_RENDER_SCHEMA);
         g_signal_connect (manager->priv->gsettings_font, "changed", G_CALLBACK (xft_callback), manager);
+        
+        /* Plugin settings (GTK modules and Xft) */
+        manager->priv->plugin_settings = g_settings_new (XSETTINGS_PLUGIN_SCHEMA);
+        g_signal_connect_object (manager->priv->plugin_settings, "changed", G_CALLBACK (plugin_callback), manager, 0);
+
         update_xft_settings (manager);
 
         start_fontconfig_monitor (manager);
 
-        for (i = 0; manager->priv->managers [i]; i++)
+        overrides = g_settings_get_value (manager->priv->plugin_settings, XSETTINGS_OVERRIDE_KEY);
+        for (i = 0; manager->priv->managers [i]; i++){
                 xsettings_manager_set_string (manager->priv->managers [i],
                                               "Net/FallbackIconTheme",
                                               "ukui");
+                xsettings_manager_set_overrides (manager->priv->managers [i], overrides);
+        }
 
         for (i = 0; manager->priv->managers [i]; i++) {
                 xsettings_manager_notify (manager->priv->managers [i]);
         }
 
+        g_variant_unref (overrides);
         ukui_settings_profile_end (NULL);
 
         return TRUE;
@@ -844,16 +1054,36 @@
                 g_object_unref (p->gsettings_font);
                 p->gsettings_font = NULL;
         }
+        if (p->plugin_settings!=NULL) {
+                g_object_unref (p->plugin_settings);
+                p->plugin_settings = NULL;
+        }
 
         stop_fontconfig_monitor (manager);
 
 }
 
+static GObject *
+ukui_xsettings_manager_constructor(GType                    type,
+                                   guint                    n_construct_properties,
+                                   GObjectConstructParam    * construct_properties)
+{
+    UkuiXSettingsManager  *xsettings_manager;
+
+    xsettings_manager = UKUI_XSETTINGS_MANAGER (G_OBJECT_CLASS(ukui_xsettings_manager_parent_class)->constructor (type,
+                                                                                                                  n_construct_properties,
+                                                                                                                  construct_properties));
+
+    return G_OBJECT (xsettings_manager);
+
+}
+
 static void
 ukui_xsettings_manager_class_init (UkuiXSettingsManagerClass *klass)
 {
         GObjectClass *object_class = G_OBJECT_CLASS (klass);
-
+        
+        object_class->constructor = ukui_xsettings_manager_constructor;
         object_class->finalize = ukui_xsettings_manager_finalize;
 
         g_type_class_add_private (klass, sizeof (UkuiXSettingsManagerPrivate));
Index: ukui-settings-daemon/plugins/xsettings/xsettings-common.c
===================================================================
--- ukui-settings-daemon.orig/plugins/xsettings/xsettings-common.c	2020-07-22 11:17:15.711393656 +0800
+++ ukui-settings-daemon/plugins/xsettings/xsettings-common.c	2020-07-22 11:21:51.987731010 +0800
@@ -20,240 +20,86 @@
  *
  * Author:  Owen Taylor, Red Hat, Inc.
  */
+
+#include <glib.h>
+
 #include "string.h"
 #include "stdlib.h"
-
 #include <X11/Xlib.h>
 #include <X11/Xmd.h>		/* For CARD32 */
 
 #include "xsettings-common.h"
 
 XSettingsSetting *
-xsettings_setting_copy (XSettingsSetting *setting)
+xsettings_setting_new (const gchar *name)
 {
   XSettingsSetting *result;
-  size_t str_len;
-  
-  result = malloc (sizeof *result);
-  if (!result)
-    return NULL;
-
-  str_len = strlen (setting->name);
-  result->name = malloc (str_len + 1);
-  if (!result->name)
-    goto err;
-
-  memcpy (result->name, setting->name, str_len + 1);
-
-  result->type = setting->type;
-
-  switch (setting->type)
-    {
-    case XSETTINGS_TYPE_INT:
-      result->data.v_int = setting->data.v_int;
-      break;
-    case XSETTINGS_TYPE_COLOR:
-      result->data.v_color = setting->data.v_color;
-      break;
-    case XSETTINGS_TYPE_STRING:
-      str_len = strlen (setting->data.v_string);
-      result->data.v_string = malloc (str_len + 1);
-      if (!result->data.v_string)
-	goto err;
-
-      memcpy (result->data.v_string, setting->data.v_string, str_len + 1);
-      break;
-    }
 
-  result->last_change_serial = setting->last_change_serial;
+  result = g_slice_new0 (XSettingsSetting);
+  result->name = g_strdup (name);
 
   return result;
-
- err:
-  if (result->name)
-    free (result->name);
-  free (result);
-  
-  return NULL;
 }
 
-XSettingsList *
-xsettings_list_copy (XSettingsList *list)
+static gboolean
+xsettings_variant_equal0 (GVariant *a,
+                          GVariant *b)
 {
-  XSettingsList *new = NULL;
-  XSettingsList *old_iter = list;
-  XSettingsList *new_iter = NULL;
-
-  while (old_iter)
-    {
-      XSettingsList *new_node;
-
-      new_node = malloc (sizeof *new_node);
-      if (!new_node)
-	goto error;
-
-      new_node->setting = xsettings_setting_copy (old_iter->setting);
-      if (!new_node->setting)
-	{
-	  free (new_node);
-	  goto error;
-	}
-
-      if (new_iter)
-	new_iter->next = new_node;
-      else
-	new = new_node;
-
-      new_iter = new_node;
-      
-      old_iter = old_iter->next;
-    }
+  if (a == b)
+    return TRUE;
 
-  return new;
+  if (!a || !b)
+    return FALSE;
 
- error:
-  xsettings_list_free (new);
-  return NULL;
+  return g_variant_equal (a, b);
 }
 
-int
-xsettings_setting_equal (XSettingsSetting *setting_a,
-			 XSettingsSetting *setting_b)
+GVariant *
+xsettings_setting_get (XSettingsSetting *setting)
 {
-  if (setting_a->type != setting_b->type)
-    return 0;
-
-  if (strcmp (setting_a->name, setting_b->name) != 0)
-    return 0;
+  gint i;
 
-  switch (setting_a->type)
-    {
-    case XSETTINGS_TYPE_INT:
-      return setting_a->data.v_int == setting_b->data.v_int;
-    case XSETTINGS_TYPE_COLOR:
-      return (setting_a->data.v_color.red == setting_b->data.v_color.red &&
-	      setting_a->data.v_color.green == setting_b->data.v_color.green &&
-	      setting_a->data.v_color.blue == setting_b->data.v_color.blue &&
-	      setting_a->data.v_color.alpha == setting_b->data.v_color.alpha);
-    case XSETTINGS_TYPE_STRING:
-      return strcmp (setting_a->data.v_string, setting_b->data.v_string) == 0;
-    }
+  for (i = G_N_ELEMENTS (setting->value) - 1; 0 <= i; i--)
+    if (setting->value[i])
+      return setting->value[i];
 
-  return 0;
+  return NULL;
 }
 
 void
-xsettings_setting_free (XSettingsSetting *setting)
-{
-  if (setting->type == XSETTINGS_TYPE_STRING)
-    free (setting->data.v_string);
-  
-  if (setting->name)
-    free (setting->name);
+xsettings_setting_set (XSettingsSetting *setting,
+                       gint              tier,
+                       GVariant         *value,
+                       guint32           serial)
+{
+  GVariant *old_value;
+
+  old_value = xsettings_setting_get (setting);
+  if (old_value)
+    g_variant_ref (old_value);
+  if (setting->value[tier])
+    g_variant_unref (setting->value[tier]);
+  setting->value[tier] = value ? g_variant_ref_sink (value) : NULL;
 
-  free (setting);
-}
-
-void
-xsettings_list_free (XSettingsList *list)
-{
-  while (list)
-    {
-      XSettingsList *next = list->next;
+  if (!xsettings_variant_equal0 (old_value, xsettings_setting_get (setting)))
+    setting->last_change_serial = serial;
 
-      xsettings_setting_free (list->setting);
-      free (list);
-
-      list = next;
-    }
-}
-
-XSettingsResult
-xsettings_list_insert (XSettingsList    **list,
-		       XSettingsSetting  *setting)
-{
-  XSettingsList *node;
-  XSettingsList *iter;
-  XSettingsList *last = NULL;
-
-  node = malloc (sizeof *node);
-  if (!node)
-    return XSETTINGS_NO_MEM;
-  node->setting = setting;
-
-  iter = *list;
-  while (iter)
-    {
-      int cmp = strcmp (setting->name, iter->setting->name);
-
-      if (cmp < 0)
-	break;
-      else if (cmp == 0)
-	{
-	  free (node);
-	  return XSETTINGS_DUPLICATE_ENTRY;
-	}
-
-      last = iter;
-      iter = iter->next;
-    }
-  
-  if (last)
-    last->next = node;
-  else
-    *list = node;
-  
-  node->next = iter;
-  
-  return XSETTINGS_SUCCESS;
+  if (old_value)
+    g_variant_unref (old_value);
 }
 
-XSettingsResult
-xsettings_list_delete (XSettingsList **list,
-		       const char     *name)
-{
-  XSettingsList *iter;
-  XSettingsList *last = NULL;
-
-  iter = *list;
-  while (iter)
-    {
-      if (strcmp (name, iter->setting->name) == 0)
-	{
-	  if (last)
-	    last->next = iter->next;
-	  else
-	    *list = iter->next;
-  
-	  xsettings_setting_free (iter->setting);
-	  free (iter);
-
-	  return XSETTINGS_SUCCESS;
-	}
-
-      last = iter;
-      iter = iter->next;
-    }
-
-  return XSETTINGS_FAILED;
-}
-
-XSettingsSetting *
-xsettings_list_lookup (XSettingsList *list,
-		       const char    *name)
+void
+xsettings_setting_free (XSettingsSetting *setting)
 {
-  XSettingsList *iter;
+  gint i;
 
-  iter = list;
-  while (iter)
-    {
-      if (strcmp (name, iter->setting->name) == 0)
-	return iter->setting;
+  for (i = 0; i < G_N_ELEMENTS (setting->value); i++)
+    if (setting->value[i])
+      g_variant_unref (setting->value[i]);
 
-      iter = iter->next;
-    }
+  g_free (setting->name);
 
-  return NULL;
+  g_slice_free (XSettingsSetting, setting);
 }
 
 char
Index: ukui-settings-daemon/plugins/xsettings/xsettings-common.h
===================================================================
--- ukui-settings-daemon.orig/plugins/xsettings/xsettings-common.h	2020-07-22 11:17:15.711393656 +0800
+++ ukui-settings-daemon/plugins/xsettings/xsettings-common.h	2020-07-22 11:21:51.987731010 +0800
@@ -23,13 +23,11 @@
 #ifndef XSETTINGS_COMMON_H
 #define XSETTINGS_COMMON_H
 
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
+#include <glib.h>
+
+#define XSETTINGS_N_TIERS 2
 
-typedef struct _XSettingsBuffer  XSettingsBuffer;
 typedef struct _XSettingsColor   XSettingsColor;
-typedef struct _XSettingsList    XSettingsList;
 typedef struct _XSettingsSetting XSettingsSetting;
 
 /* Types of settings possible. Enum values correspond to
@@ -42,69 +40,26 @@
   XSETTINGS_TYPE_COLOR   = 2
 } XSettingsType;
 
-typedef enum
-{
-  XSETTINGS_SUCCESS,
-  XSETTINGS_NO_MEM,
-  XSETTINGS_ACCESS,
-  XSETTINGS_FAILED,
-  XSETTINGS_NO_ENTRY,
-  XSETTINGS_DUPLICATE_ENTRY
-} XSettingsResult;
-
-struct _XSettingsBuffer
-{
-  char byte_order;
-  size_t len;
-  unsigned char *data;
-  unsigned char *pos;
-};
-
 struct _XSettingsColor
 {
   unsigned short red, green, blue, alpha;
 };
 
-struct _XSettingsList
-{
-  XSettingsSetting *setting;
-  XSettingsList *next;
-};
-
 struct _XSettingsSetting
 {
   char *name;
-  XSettingsType type;
-  
-  union {
-    int v_int;
-    char *v_string;
-    XSettingsColor v_color;
-  } data;
-
+  GVariant *value[XSETTINGS_N_TIERS];
   unsigned long last_change_serial;
 };
 
-XSettingsSetting *xsettings_setting_copy  (XSettingsSetting *setting);
+XSettingsSetting *xsettings_setting_new   (const gchar      *name);
+GVariant *        xsettings_setting_get   (XSettingsSetting *setting);
+void              xsettings_setting_set   (XSettingsSetting *setting,
+                                           gint              tier,
+                                           GVariant         *value,
+                                           guint32           serial);
 void              xsettings_setting_free  (XSettingsSetting *setting);
-int               xsettings_setting_equal (XSettingsSetting *setting_a,
-					   XSettingsSetting *setting_b);
-
-void              xsettings_list_free   (XSettingsList     *list);
-XSettingsList    *xsettings_list_copy   (XSettingsList     *list);
-XSettingsResult   xsettings_list_insert (XSettingsList    **list,
-					 XSettingsSetting  *setting);
-XSettingsSetting *xsettings_list_lookup (XSettingsList     *list,
-					 const char        *name);
-XSettingsResult   xsettings_list_delete (XSettingsList    **list,
-					 const char        *name);
 
 char xsettings_byte_order (void);
 
-#define XSETTINGS_PAD(n,m) ((n + m - 1) & (~(m-1)))
-
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
-
 #endif /* XSETTINGS_COMMON_H */
Index: ukui-settings-daemon/plugins/xsettings/xsettings-manager.c
===================================================================
--- ukui-settings-daemon.orig/plugins/xsettings/xsettings-manager.c	2020-07-22 11:17:15.711393656 +0800
+++ ukui-settings-daemon/plugins/xsettings/xsettings-manager.c	2020-07-22 11:21:51.987731010 +0800
@@ -15,7 +15,7 @@
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL RED HAT
  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  *
  * Author:  Owen Taylor, Red Hat, Inc.
@@ -23,11 +23,13 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-
+#include <glib.h>
 #include <X11/Xmd.h>		/* For CARD16 */
 
 #include "xsettings-manager.h"
 
+#define XSETTINGS_VARIANT_TYPE_COLOR  (G_VARIANT_TYPE ("(qqqq)"))
+
 struct _XSettingsManager
 {
   Display *display;
@@ -41,13 +43,13 @@
   XSettingsTerminateFunc terminate;
   void *cb_data;
 
-  XSettingsList *settings;
+  GHashTable *settings;
   unsigned long serial;
-};
 
-static XSettingsList *settings;
+  GVariant *overrides;
+};
 
-typedef struct
+typedef struct 
 {
   Window window;
   Atom timestamp_prop_atom;
@@ -74,9 +76,9 @@
  * @window: a #Window, used for communication with the server.
  *          The window must have PropertyChangeMask in its
  *          events mask or a hang will result.
- *
- * Routine to get the current X server time stamp.
- *
+ * 
+ * Routine to get the current X server time stamp. 
+ * 
  * Return value: the time stamp.
  **/
 static Time
@@ -106,7 +108,7 @@
 {
   char buffer[256];
   Atom selection_atom;
-
+  
   sprintf(buffer, "_XSETTINGS_S%d", screen);
   selection_atom = XInternAtom (display, buffer, False);
 
@@ -128,9 +130,7 @@
 
   char buffer[256];
 
-  manager = malloc (sizeof *manager);
-  if (!manager)
-    return NULL;
+  manager = g_slice_new (XSettingsManager);
 
   manager->display = display;
   manager->screen = screen;
@@ -143,8 +143,9 @@
   manager->terminate = terminate;
   manager->cb_data = cb_data;
 
-  manager->settings = NULL;
+  manager->settings = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, (GDestroyNotify) xsettings_setting_free);
   manager->serial = 0;
+  manager->overrides = NULL;
 
   manager->window = XCreateSimpleWindow (display,
 					 RootWindow (display, screen),
@@ -174,7 +175,7 @@
       xev.data.l[2] = manager->window;
       xev.data.l[3] = 0;	/* manager specific data */
       xev.data.l[4] = 0;	/* manager specific data */
-
+      
       XSendEvent (display, RootWindow (display, screen),
 		  False, StructureNotifyMask, (XEvent *)&xev);
     }
@@ -182,7 +183,7 @@
     {
       manager->terminate (manager->cb_data);
     }
-
+  
   return manager;
 }
 
@@ -191,234 +192,201 @@
 {
   XDestroyWindow (manager->display, manager->window);
 
-  xsettings_list_free (manager->settings);
-  free (manager);
-}
-
-Window
-xsettings_manager_get_window (XSettingsManager *manager)
-{
-  return manager->window;
-}
-
-Bool
-xsettings_manager_process_event (XSettingsManager *manager,
-				 XEvent           *xev)
-{
-  if (xev->xany.window == manager->window &&
-      xev->xany.type == SelectionClear &&
-      xev->xselectionclear.selection == manager->selection_atom)
-    {
-      manager->terminate (manager->cb_data);
-      return True;
-    }
-
-  return False;
-}
+  g_hash_table_unref (manager->settings);
 
-XSettingsResult
-xsettings_manager_delete_setting (XSettingsManager *manager,
-                                  const char       *name)
-{
-  return xsettings_list_delete (&settings, name);
+  g_slice_free (XSettingsManager, manager);
 }
 
-XSettingsResult
+static void
 xsettings_manager_set_setting (XSettingsManager *manager,
-			       XSettingsSetting *setting)
+                               const gchar      *name,
+                               gint              tier,
+                               GVariant         *value)
 {
-  XSettingsSetting *old_setting = xsettings_list_lookup (settings, setting->name);
-  XSettingsSetting *new_setting;
-  XSettingsResult result;
+  XSettingsSetting *setting;
 
-  if (old_setting)
-    {
-      if (xsettings_setting_equal (old_setting, setting))
-	return XSETTINGS_SUCCESS;
+  setting = g_hash_table_lookup (manager->settings, name);
 
-      xsettings_list_delete (&settings, setting->name);
+  if (setting == NULL)
+    {
+      setting = xsettings_setting_new (name);
+      setting->last_change_serial = manager->serial;
+      g_hash_table_insert (manager->settings, setting->name, setting);
     }
 
-  new_setting = xsettings_setting_copy (setting);
-  if (!new_setting)
-    return XSETTINGS_NO_MEM;
+  xsettings_setting_set (setting, tier, value, manager->serial);
 
-  new_setting->last_change_serial = manager->serial;
-
-  result = xsettings_list_insert (&settings, new_setting);
-
-  if (result != XSETTINGS_SUCCESS)
-    xsettings_setting_free (new_setting);
-
-  return result;
+  if (xsettings_setting_get (setting) == NULL)
+    g_hash_table_remove (manager->settings, name);
 }
 
-XSettingsResult
+void
 xsettings_manager_set_int (XSettingsManager *manager,
 			   const char       *name,
 			   int               value)
 {
-  XSettingsSetting setting;
-
-  setting.name = (char *)name;
-  setting.type = XSETTINGS_TYPE_INT;
-  setting.data.v_int = value;
-
-  return xsettings_manager_set_setting (manager, &setting);
+  xsettings_manager_set_setting (manager, name, 0, g_variant_new_int32 (value));
 }
 
-XSettingsResult
+void
 xsettings_manager_set_string (XSettingsManager *manager,
 			      const char       *name,
 			      const char       *value)
 {
-  XSettingsSetting setting;
-
-  setting.name = (char *)name;
-  setting.type = XSETTINGS_TYPE_STRING;
-  setting.data.v_string = (char *)value;
-
-  return xsettings_manager_set_setting (manager, &setting);
+  xsettings_manager_set_setting (manager, name, 0, g_variant_new_string (value));
 }
 
-XSettingsResult
+void
 xsettings_manager_set_color (XSettingsManager *manager,
 			     const char       *name,
 			     XSettingsColor   *value)
 {
-  XSettingsSetting setting;
+  GVariant *tmp;
 
-  setting.name = (char *)name;
-  setting.type = XSETTINGS_TYPE_COLOR;
-  setting.data.v_color = *value;
-
-  return xsettings_manager_set_setting (manager, &setting);
+  tmp = g_variant_new ("(qqqq)", value->red, value->green, value->blue, value->alpha);
+  g_assert (g_variant_is_of_type (tmp, XSETTINGS_VARIANT_TYPE_COLOR)); /* paranoia... */
+  xsettings_manager_set_setting (manager, name, 0, tmp);
 }
 
-static size_t
-setting_length (XSettingsSetting *setting)
+void
+xsettings_manager_delete_setting (XSettingsManager *manager,
+                                  const char       *name)
 {
-  size_t length = 8;	/* type + pad + name-len + last-change-serial */
-  length += XSETTINGS_PAD (strlen (setting->name), 4);
+  xsettings_manager_set_setting (manager, name, 0, NULL);
+}
 
-  switch (setting->type)
+static gchar
+xsettings_get_typecode (GVariant *value)
+{
+  switch (g_variant_classify (value))
     {
-    case XSETTINGS_TYPE_INT:
-      length += 4;
-      break;
-    case XSETTINGS_TYPE_STRING:
-      length += 4 + XSETTINGS_PAD (strlen (setting->data.v_string), 4);
-      break;
-    case XSETTINGS_TYPE_COLOR:
-      length += 8;
-      break;
+    case G_VARIANT_CLASS_INT32:
+      return XSETTINGS_TYPE_INT;
+    case G_VARIANT_CLASS_STRING:
+      return XSETTINGS_TYPE_STRING;
+    case G_VARIANT_CLASS_TUPLE:
+      return XSETTINGS_TYPE_COLOR;
+    default:
+      g_assert_not_reached ();
     }
+}
 
-  return length;
+static void
+align_string (GString *string,
+              gint     alignment)
+{
+  /* Adds nul-bytes to the string until its length is an even multiple
+   * of the specified alignment requirement.
+   */
+  while ((string->len % alignment) != 0)
+    g_string_append_c (string, '\0');
 }
 
 static void
 setting_store (XSettingsSetting *setting,
-	       XSettingsBuffer *buffer)
+               GString          *buffer)
 {
-  size_t string_len;
-  size_t length;
+  XSettingsType type;
+  GVariant *value;
+  guint16 len16;
 
-  *(buffer->pos++) = setting->type;
-  *(buffer->pos++) = 0;
+  value = xsettings_setting_get (setting);
 
-  string_len = strlen (setting->name);
-  *(CARD16 *)(buffer->pos) = string_len;
-  buffer->pos += 2;
+  type = xsettings_get_typecode (value);
 
-  length = XSETTINGS_PAD (string_len, 4);
-  memcpy (buffer->pos, setting->name, string_len);
-  length -= string_len;
-  buffer->pos += string_len;
+  g_string_append_c (buffer, type);
+  g_string_append_c (buffer, 0);
 
-  while (length > 0)
-    {
-      *(buffer->pos++) = 0;
-      length--;
-    }
+  len16 = strlen (setting->name);
+  g_string_append_len (buffer, (gchar *) &len16, 2);
+  g_string_append (buffer, setting->name);
+  align_string (buffer, 4);
 
-  *(CARD32 *)(buffer->pos) = setting->last_change_serial;
-  buffer->pos += 4;
+  g_string_append_len (buffer, (gchar *) &setting->last_change_serial, 4);
 
-  switch (setting->type)
+  if (type == XSETTINGS_TYPE_STRING)
     {
-    case XSETTINGS_TYPE_INT:
-      *(CARD32 *)(buffer->pos) = setting->data.v_int;
-      buffer->pos += 4;
-      break;
-    case XSETTINGS_TYPE_STRING:
-      string_len = strlen (setting->data.v_string);
-      *(CARD32 *)(buffer->pos) = string_len;
-      buffer->pos += 4;
-
-      length = XSETTINGS_PAD (string_len, 4);
-      memcpy (buffer->pos, setting->data.v_string, string_len);
-      length -= string_len;
-      buffer->pos += string_len;
-
-      while (length > 0)
-	{
-	  *(buffer->pos++) = 0;
-	  length--;
-	}
-      break;
-    case XSETTINGS_TYPE_COLOR:
-      *(CARD16 *)(buffer->pos) = setting->data.v_color.red;
-      *(CARD16 *)(buffer->pos + 2) = setting->data.v_color.green;
-      *(CARD16 *)(buffer->pos + 4) = setting->data.v_color.blue;
-      *(CARD16 *)(buffer->pos + 6) = setting->data.v_color.alpha;
-      buffer->pos += 8;
-      break;
+      const gchar *string;
+      gsize stringlen;
+      guint32 len32;
+
+      string = g_variant_get_string (value, &stringlen);
+      len32 = stringlen;
+      g_string_append_len (buffer, (gchar *) &len32, 4);
+      g_string_append (buffer, string);
+      align_string (buffer, 4);
     }
+  else
+    /* GVariant format is the same as XSETTINGS format for the non-string types */
+    g_string_append_len (buffer, g_variant_get_data (value), g_variant_get_size (value));
 }
 
-XSettingsResult
+void
 xsettings_manager_notify (XSettingsManager *manager)
 {
-  XSettingsBuffer buffer;
-  XSettingsList *iter;
-  int n_settings = 0;
+  GString *buffer;
+  GHashTableIter iter;
+  int n_settings;
+  gpointer value;
+
+  n_settings = g_hash_table_size (manager->settings);
+
+  buffer = g_string_new (NULL);
+  g_string_append_c (buffer, xsettings_byte_order ());
+  g_string_append_c (buffer, '\0');
+  g_string_append_c (buffer, '\0');
+  g_string_append_c (buffer, '\0');
+
+  g_string_append_len (buffer, (gchar *) &manager->serial, 4);
+  g_string_append_len (buffer, (gchar *) &n_settings, 4);
+
+  g_hash_table_iter_init (&iter, manager->settings);
+  while (g_hash_table_iter_next (&iter, NULL, &value))
+    setting_store (value, buffer);
 
-  buffer.len = 12;		/* byte-order + pad + SERIAL + N_SETTINGS */
+  XChangeProperty (manager->display, manager->window,
+                   manager->xsettings_atom, manager->xsettings_atom,
+                   8, PropModeReplace, (guchar *) buffer->str, buffer->len);
 
-  iter = settings;
-  while (iter)
-    {
-      buffer.len += setting_length (iter->setting);
-      n_settings++;
-      iter = iter->next;
-    }
+  g_string_free (buffer, TRUE);
+  manager->serial++;
+}
 
-  buffer.data = buffer.pos = malloc (buffer.len);
-  if (!buffer.data)
-    return XSETTINGS_NO_MEM;
-
-  *buffer.pos = xsettings_byte_order ();
-
-  buffer.pos += 4;
-  *(CARD32 *)buffer.pos = manager->serial++;
-  buffer.pos += 4;
-  *(CARD32 *)buffer.pos = n_settings;
-  buffer.pos += 4;
+void
+xsettings_manager_set_overrides (XSettingsManager *manager,
+                                 GVariant         *overrides)
+{
+  GVariantIter iter;
+  const gchar *key;
+  GVariant *value;
 
-  iter = settings;
-  while (iter)
+  g_return_if_fail (overrides != NULL && g_variant_is_of_type (overrides, G_VARIANT_TYPE_VARDICT));
+
+  if (manager->overrides)
     {
-      setting_store (iter->setting, &buffer);
-      iter = iter->next;
+      /* unset the existing overrides */
+
+      g_variant_iter_init (&iter, manager->overrides);
+      while (g_variant_iter_next (&iter, "{&sv}", &key, NULL))
+        /* only unset it at this point if it's not in the new list */
+        if (!g_variant_lookup (overrides, key, "*", NULL))
+          xsettings_manager_set_setting (manager, key, 1, NULL);
+      g_variant_unref (manager->overrides);
     }
 
-  XChangeProperty (manager->display, manager->window,
-		   manager->xsettings_atom, manager->xsettings_atom,
-		   8, PropModeReplace, buffer.data, buffer.len);
+  /* save this so we can do the unsets next time */
+  manager->overrides = g_variant_ref_sink (overrides);
 
-  free (buffer.data);
+  /* set the new values */
+  g_variant_iter_init (&iter, overrides);
+  while (g_variant_iter_loop (&iter, "{&sv}", &key, &value))
+    {
+      /* only accept recognised types... */
+      if (!g_variant_is_of_type (value, G_VARIANT_TYPE_STRING) &&
+          !g_variant_is_of_type (value, G_VARIANT_TYPE_INT32) &&
+          !g_variant_is_of_type (value, XSETTINGS_VARIANT_TYPE_COLOR))
+        continue;
 
-  return XSETTINGS_SUCCESS;
+      xsettings_manager_set_setting (manager, key, 1, value);
+    }
 }
-
Index: ukui-settings-daemon/plugins/xsettings/xsettings-manager.h
===================================================================
--- ukui-settings-daemon.orig/plugins/xsettings/xsettings-manager.h	2020-07-22 11:17:15.711393656 +0800
+++ ukui-settings-daemon/plugins/xsettings/xsettings-manager.h	2020-07-22 11:21:51.987731010 +0800
@@ -26,10 +26,6 @@
 #include <X11/Xlib.h>
 #include "xsettings-common.h"
 
-#ifdef __cplusplus
-extern "C" {
-#endif /* __cplusplus */
-
 typedef struct _XSettingsManager XSettingsManager;
 
 typedef void (*XSettingsTerminateFunc)  (void *cb_data);
@@ -43,29 +39,20 @@
 					 void                   *cb_data);
 
 void   xsettings_manager_destroy       (XSettingsManager *manager);
-Window xsettings_manager_get_window    (XSettingsManager *manager);
-Bool   xsettings_manager_process_event (XSettingsManager *manager,
-					XEvent           *xev);
-
-XSettingsResult xsettings_manager_delete_setting (XSettingsManager *manager,
-                                                  const char       *name);
-XSettingsResult xsettings_manager_set_setting    (XSettingsManager *manager,
-                                                  XSettingsSetting *setting);
-XSettingsResult xsettings_manager_set_int        (XSettingsManager *manager,
-                                                  const char       *name,
-                                                  int               value);
-XSettingsResult xsettings_manager_set_string     (XSettingsManager *manager,
-                                                  const char       *name,
-                                                  const char       *value);
-XSettingsResult xsettings_manager_set_color      (XSettingsManager *manager,
-                                                  const char       *name,
-                                                  XSettingsColor   *value);
-XSettingsResult xsettings_manager_notify         (XSettingsManager *manager);
-
-
 
-#ifdef __cplusplus
-}
-#endif /* __cplusplus */
+void   xsettings_manager_delete_setting (XSettingsManager *manager,
+                                         const char       *name);
+void   xsettings_manager_set_int        (XSettingsManager *manager,
+                                         const char       *name,
+                                         int               value);
+void   xsettings_manager_set_string     (XSettingsManager *manager,
+                                         const char       *name,
+                                         const char       *value);
+void   xsettings_manager_set_color      (XSettingsManager *manager,
+                                         const char       *name,
+                                         XSettingsColor   *value);
+void   xsettings_manager_notify         (XSettingsManager *manager);
+void   xsettings_manager_set_overrides  (XSettingsManager *manager,
+                                         GVariant         *overrides);
 
 #endif /* XSETTINGS_MANAGER_H */
